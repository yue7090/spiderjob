// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: spiderjob.proto

package types

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	// protobuf "google/protobuf"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Job struct {
	Name                 string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Timezone             string                   `protobuf:"bytes,2,opt,name=timezone,proto3" json:"timezone,omitempty"`
	Schedule             string                   `protobuf:"bytes,3,opt,name=schedule,proto3" json:"schedule,omitempty"`
	Owner                string                   `protobuf:"bytes,7,opt,name=owner,proto3" json:"owner,omitempty"`
	OwnerEmail           string                   `protobuf:"bytes,8,opt,name=owner_email,json=ownerEmail,proto3" json:"owner_email,omitempty"`
	SuccessCount         int32                    `protobuf:"varint,9,opt,name=success_count,json=successCount,proto3" json:"success_count,omitempty"`
	ErrorCount           int32                    `protobuf:"varint,10,opt,name=error_count,json=errorCount,proto3" json:"error_count,omitempty"`
	Disabled             bool                     `protobuf:"varint,11,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Tags                 map[string]string        `protobuf:"bytes,12,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Retries              uint32                   `protobuf:"varint,13,opt,name=retries,proto3" json:"retries,omitempty"`
	DependentJobs        []string                 `protobuf:"bytes,14,rep,name=dependent_jobs,json=dependentJobs,proto3" json:"dependent_jobs,omitempty"`
	ParentJob            string                   `protobuf:"bytes,15,opt,name=parent_job,json=parentJob,proto3" json:"parent_job,omitempty"`
	Concurrency          string                   `protobuf:"bytes,16,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	Executor             string                   `protobuf:"bytes,17,opt,name=executor,proto3" json:"executor,omitempty"`
	ExecutorConfig       map[string]string        `protobuf:"bytes,18,rep,name=executor_config,json=executorConfig,proto3" json:"executor_config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Status               string                   `protobuf:"bytes,19,opt,name=status,proto3" json:"status,omitempty"`
	Metadata             map[string]string        `protobuf:"bytes,20,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	LastSuccess          *Job_NullableTime        `protobuf:"bytes,25,opt,name=last_success,json=lastSuccess,proto3" json:"last_success,omitempty"`
	LastError            *Job_NullableTime        `protobuf:"bytes,26,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`
	Next                 *protobuf.Timestamp      `protobuf:"bytes,23,opt,name=next,proto3" json:"next,omitempty"`
	Displayname          string                   `protobuf:"bytes,24,opt,name=displayname,proto3" json:"displayname,omitempty"`
	Processors           map[string]*PluginConfig `protobuf:"bytes,27,rep,name=processors,proto3" json:"processors,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{0}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Job) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

func (m *Job) GetSchedule() string {
	if m != nil {
		return m.Schedule
	}
	return ""
}

func (m *Job) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Job) GetOwnerEmail() string {
	if m != nil {
		return m.OwnerEmail
	}
	return ""
}

func (m *Job) GetSuccessCount() int32 {
	if m != nil {
		return m.SuccessCount
	}
	return 0
}

func (m *Job) GetErrorCount() int32 {
	if m != nil {
		return m.ErrorCount
	}
	return 0
}

func (m *Job) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *Job) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Job) GetRetries() uint32 {
	if m != nil {
		return m.Retries
	}
	return 0
}

func (m *Job) GetDependentJobs() []string {
	if m != nil {
		return m.DependentJobs
	}
	return nil
}

func (m *Job) GetParentJob() string {
	if m != nil {
		return m.ParentJob
	}
	return ""
}

func (m *Job) GetConcurrency() string {
	if m != nil {
		return m.Concurrency
	}
	return ""
}

func (m *Job) GetExecutor() string {
	if m != nil {
		return m.Executor
	}
	return ""
}

func (m *Job) GetExecutorConfig() map[string]string {
	if m != nil {
		return m.ExecutorConfig
	}
	return nil
}

func (m *Job) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Job) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Job) GetLastSuccess() *Job_NullableTime {
	if m != nil {
		return m.LastSuccess
	}
	return nil
}

func (m *Job) GetLastError() *Job_NullableTime {
	if m != nil {
		return m.LastError
	}
	return nil
}

func (m *Job) GetNext() *protobuf.Timestamp {
	if m != nil {
		return m.Next
	}
	return nil
}

func (m *Job) GetDisplayname() string {
	if m != nil {
		return m.Displayname
	}
	return ""
}

func (m *Job) GetProcessors() map[string]*PluginConfig {
	if m != nil {
		return m.Processors
	}
	return nil
}

type Job_NullableTime struct {
	HasValue             bool                `protobuf:"varint,1,opt,name=has_value,json=hasValue,proto3" json:"has_value,omitempty"`
	Time                 *protobuf.Timestamp `protobuf:"bytes,2,opt,name=time,proto3" json:"time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Job_NullableTime) Reset()         { *m = Job_NullableTime{} }
func (m *Job_NullableTime) String() string { return proto.CompactTextString(m) }
func (*Job_NullableTime) ProtoMessage()    {}
func (*Job_NullableTime) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{0, 3}
}
func (m *Job_NullableTime) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job_NullableTime) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job_NullableTime.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job_NullableTime) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job_NullableTime.Merge(m, src)
}
func (m *Job_NullableTime) XXX_Size() int {
	return m.Size()
}
func (m *Job_NullableTime) XXX_DiscardUnknown() {
	xxx_messageInfo_Job_NullableTime.DiscardUnknown(m)
}

var xxx_messageInfo_Job_NullableTime proto.InternalMessageInfo

func (m *Job_NullableTime) GetHasValue() bool {
	if m != nil {
		return m.HasValue
	}
	return false
}

func (m *Job_NullableTime) GetTime() *protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type PluginConfig struct {
	Config               map[string]string `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PluginConfig) Reset()         { *m = PluginConfig{} }
func (m *PluginConfig) String() string { return proto.CompactTextString(m) }
func (*PluginConfig) ProtoMessage()    {}
func (*PluginConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{1}
}
func (m *PluginConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PluginConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PluginConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PluginConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PluginConfig.Merge(m, src)
}
func (m *PluginConfig) XXX_Size() int {
	return m.Size()
}
func (m *PluginConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_PluginConfig.DiscardUnknown(m)
}

var xxx_messageInfo_PluginConfig proto.InternalMessageInfo

func (m *PluginConfig) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

type SetJobRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetJobRequest) Reset()         { *m = SetJobRequest{} }
func (m *SetJobRequest) String() string { return proto.CompactTextString(m) }
func (*SetJobRequest) ProtoMessage()    {}
func (*SetJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{2}
}
func (m *SetJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetJobRequest.Merge(m, src)
}
func (m *SetJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetJobRequest proto.InternalMessageInfo

func (m *SetJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type SetJobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetJobResponse) Reset()         { *m = SetJobResponse{} }
func (m *SetJobResponse) String() string { return proto.CompactTextString(m) }
func (*SetJobResponse) ProtoMessage()    {}
func (*SetJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{3}
}
func (m *SetJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetJobResponse.Merge(m, src)
}
func (m *SetJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetJobResponse proto.InternalMessageInfo

func (m *SetJobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type DeleteJobRequest struct {
	JobName              string   `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"job_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobRequest) Reset()         { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()    {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{4}
}
func (m *DeleteJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobRequest.Merge(m, src)
}
func (m *DeleteJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobRequest proto.InternalMessageInfo

func (m *DeleteJobRequest) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

type DeleteJobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobResponse) Reset()         { *m = DeleteJobResponse{} }
func (m *DeleteJobResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteJobResponse) ProtoMessage()    {}
func (*DeleteJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{5}
}
func (m *DeleteJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobResponse.Merge(m, src)
}
func (m *DeleteJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobResponse proto.InternalMessageInfo

func (m *DeleteJobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type GetJobRequest struct {
	JobName              string   `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"job_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobRequest) Reset()         { *m = GetJobRequest{} }
func (m *GetJobRequest) String() string { return proto.CompactTextString(m) }
func (*GetJobRequest) ProtoMessage()    {}
func (*GetJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{6}
}
func (m *GetJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobRequest.Merge(m, src)
}
func (m *GetJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobRequest proto.InternalMessageInfo

func (m *GetJobRequest) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

type GetJobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetJobResponse) Reset()         { *m = GetJobResponse{} }
func (m *GetJobResponse) String() string { return proto.CompactTextString(m) }
func (*GetJobResponse) ProtoMessage()    {}
func (*GetJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{7}
}
func (m *GetJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetJobResponse.Merge(m, src)
}
func (m *GetJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetJobResponse proto.InternalMessageInfo

func (m *GetJobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type Execution struct {
	JobName              string              `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"job_name,omitempty"`
	Success              bool                `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	Output               []byte              `protobuf:"bytes,3,opt,name=output,proto3" json:"output,omitempty"`
	NodeName             string              `protobuf:"bytes,4,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	Group                int64               `protobuf:"varint,5,opt,name=group,proto3" json:"group,omitempty"`
	Attempt              uint32              `protobuf:"varint,6,opt,name=attempt,proto3" json:"attempt,omitempty"`
	StartedAt            *protobuf.Timestamp `protobuf:"bytes,7,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	FinishedAt           *protobuf.Timestamp `protobuf:"bytes,8,opt,name=finished_at,json=finishedAt,proto3" json:"finished_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{8}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

func (m *Execution) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Execution) GetOutput() []byte {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *Execution) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *Execution) GetGroup() int64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Execution) GetAttempt() uint32 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

func (m *Execution) GetStartedAt() *protobuf.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *Execution) GetFinishedAt() *protobuf.Timestamp {
	if m != nil {
		return m.FinishedAt
	}
	return nil
}

type ExecutionDoneRequest struct {
	Execution            *Execution `protobuf:"bytes,1,opt,name=execution,proto3" json:"execution,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ExecutionDoneRequest) Reset()         { *m = ExecutionDoneRequest{} }
func (m *ExecutionDoneRequest) String() string { return proto.CompactTextString(m) }
func (*ExecutionDoneRequest) ProtoMessage()    {}
func (*ExecutionDoneRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{9}
}
func (m *ExecutionDoneRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionDoneRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionDoneRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionDoneRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionDoneRequest.Merge(m, src)
}
func (m *ExecutionDoneRequest) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionDoneRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionDoneRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionDoneRequest proto.InternalMessageInfo

func (m *ExecutionDoneRequest) GetExecution() *Execution {
	if m != nil {
		return m.Execution
	}
	return nil
}

type ExecutionDoneResponse struct {
	From                 string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Payload              []byte   `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecutionDoneResponse) Reset()         { *m = ExecutionDoneResponse{} }
func (m *ExecutionDoneResponse) String() string { return proto.CompactTextString(m) }
func (*ExecutionDoneResponse) ProtoMessage()    {}
func (*ExecutionDoneResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{10}
}
func (m *ExecutionDoneResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionDoneResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionDoneResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionDoneResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionDoneResponse.Merge(m, src)
}
func (m *ExecutionDoneResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionDoneResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionDoneResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionDoneResponse proto.InternalMessageInfo

func (m *ExecutionDoneResponse) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *ExecutionDoneResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RunJobRequest struct {
	JobName              string   `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"job_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunJobRequest) Reset()         { *m = RunJobRequest{} }
func (m *RunJobRequest) String() string { return proto.CompactTextString(m) }
func (*RunJobRequest) ProtoMessage()    {}
func (*RunJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{11}
}
func (m *RunJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunJobRequest.Merge(m, src)
}
func (m *RunJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunJobRequest proto.InternalMessageInfo

func (m *RunJobRequest) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

type RunJobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunJobResponse) Reset()         { *m = RunJobResponse{} }
func (m *RunJobResponse) String() string { return proto.CompactTextString(m) }
func (*RunJobResponse) ProtoMessage()    {}
func (*RunJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{12}
}
func (m *RunJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunJobResponse.Merge(m, src)
}
func (m *RunJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunJobResponse proto.InternalMessageInfo

func (m *RunJobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type ToggleJobRequest struct {
	JobName              string   `protobuf:"bytes,1,opt,name=job_name,json=jobName,proto3" json:"job_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ToggleJobRequest) Reset()         { *m = ToggleJobRequest{} }
func (m *ToggleJobRequest) String() string { return proto.CompactTextString(m) }
func (*ToggleJobRequest) ProtoMessage()    {}
func (*ToggleJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{13}
}
func (m *ToggleJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToggleJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToggleJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToggleJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToggleJobRequest.Merge(m, src)
}
func (m *ToggleJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *ToggleJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ToggleJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ToggleJobRequest proto.InternalMessageInfo

func (m *ToggleJobRequest) GetJobName() string {
	if m != nil {
		return m.JobName
	}
	return ""
}

type ToggleJobResponse struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ToggleJobResponse) Reset()         { *m = ToggleJobResponse{} }
func (m *ToggleJobResponse) String() string { return proto.CompactTextString(m) }
func (*ToggleJobResponse) ProtoMessage()    {}
func (*ToggleJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{14}
}
func (m *ToggleJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ToggleJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ToggleJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ToggleJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ToggleJobResponse.Merge(m, src)
}
func (m *ToggleJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *ToggleJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ToggleJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ToggleJobResponse proto.InternalMessageInfo

func (m *ToggleJobResponse) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type RaftServer struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Node                 string   `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
	Address              string   `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	Leader               bool     `protobuf:"varint,4,opt,name=leader,proto3" json:"leader,omitempty"`
	Voter                bool     `protobuf:"varint,5,opt,name=voter,proto3" json:"voter,omitempty"`
	RaftProtocol         string   `protobuf:"bytes,6,opt,name=raft_protocol,json=raftProtocol,proto3" json:"raft_protocol,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftServer) Reset()         { *m = RaftServer{} }
func (m *RaftServer) String() string { return proto.CompactTextString(m) }
func (*RaftServer) ProtoMessage()    {}
func (*RaftServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{15}
}
func (m *RaftServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftServer.Merge(m, src)
}
func (m *RaftServer) XXX_Size() int {
	return m.Size()
}
func (m *RaftServer) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftServer.DiscardUnknown(m)
}

var xxx_messageInfo_RaftServer proto.InternalMessageInfo

func (m *RaftServer) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RaftServer) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *RaftServer) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaftServer) GetLeader() bool {
	if m != nil {
		return m.Leader
	}
	return false
}

func (m *RaftServer) GetVoter() bool {
	if m != nil {
		return m.Voter
	}
	return false
}

func (m *RaftServer) GetRaftProtocol() string {
	if m != nil {
		return m.RaftProtocol
	}
	return ""
}

type RaftGetConfigurationResponse struct {
	Servers              []*RaftServer `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	Index                uint64        `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RaftGetConfigurationResponse) Reset()         { *m = RaftGetConfigurationResponse{} }
func (m *RaftGetConfigurationResponse) String() string { return proto.CompactTextString(m) }
func (*RaftGetConfigurationResponse) ProtoMessage()    {}
func (*RaftGetConfigurationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{16}
}
func (m *RaftGetConfigurationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftGetConfigurationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftGetConfigurationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftGetConfigurationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftGetConfigurationResponse.Merge(m, src)
}
func (m *RaftGetConfigurationResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftGetConfigurationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftGetConfigurationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftGetConfigurationResponse proto.InternalMessageInfo

func (m *RaftGetConfigurationResponse) GetServers() []*RaftServer {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *RaftGetConfigurationResponse) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

type RaftRemovePeerByIDRequest struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RaftRemovePeerByIDRequest) Reset()         { *m = RaftRemovePeerByIDRequest{} }
func (m *RaftRemovePeerByIDRequest) String() string { return proto.CompactTextString(m) }
func (*RaftRemovePeerByIDRequest) ProtoMessage()    {}
func (*RaftRemovePeerByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{17}
}
func (m *RaftRemovePeerByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRemovePeerByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftRemovePeerByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftRemovePeerByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRemovePeerByIDRequest.Merge(m, src)
}
func (m *RaftRemovePeerByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftRemovePeerByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRemovePeerByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRemovePeerByIDRequest proto.InternalMessageInfo

func (m *RaftRemovePeerByIDRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type AgentRunStream struct {
	Execution            *Execution `protobuf:"bytes,1,opt,name=execution,proto3" json:"execution,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AgentRunStream) Reset()         { *m = AgentRunStream{} }
func (m *AgentRunStream) String() string { return proto.CompactTextString(m) }
func (*AgentRunStream) ProtoMessage()    {}
func (*AgentRunStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{18}
}
func (m *AgentRunStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentRunStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentRunStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentRunStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentRunStream.Merge(m, src)
}
func (m *AgentRunStream) XXX_Size() int {
	return m.Size()
}
func (m *AgentRunStream) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentRunStream.DiscardUnknown(m)
}

var xxx_messageInfo_AgentRunStream proto.InternalMessageInfo

func (m *AgentRunStream) GetExecution() *Execution {
	if m != nil {
		return m.Execution
	}
	return nil
}

type AgentRunResponse struct {
	From                 string   `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Payload              []byte   `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AgentRunResponse) Reset()         { *m = AgentRunResponse{} }
func (m *AgentRunResponse) String() string { return proto.CompactTextString(m) }
func (*AgentRunResponse) ProtoMessage()    {}
func (*AgentRunResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{19}
}
func (m *AgentRunResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentRunResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentRunResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentRunResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentRunResponse.Merge(m, src)
}
func (m *AgentRunResponse) XXX_Size() int {
	return m.Size()
}
func (m *AgentRunResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentRunResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AgentRunResponse proto.InternalMessageInfo

func (m *AgentRunResponse) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *AgentRunResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type GetActiveExecutionsResponse struct {
	Executions           []*Execution `protobuf:"bytes,1,rep,name=executions,proto3" json:"executions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetActiveExecutionsResponse) Reset()         { *m = GetActiveExecutionsResponse{} }
func (m *GetActiveExecutionsResponse) String() string { return proto.CompactTextString(m) }
func (*GetActiveExecutionsResponse) ProtoMessage()    {}
func (*GetActiveExecutionsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{20}
}
func (m *GetActiveExecutionsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetActiveExecutionsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetActiveExecutionsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetActiveExecutionsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetActiveExecutionsResponse.Merge(m, src)
}
func (m *GetActiveExecutionsResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetActiveExecutionsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetActiveExecutionsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetActiveExecutionsResponse proto.InternalMessageInfo

func (m *GetActiveExecutionsResponse) GetExecutions() []*Execution {
	if m != nil {
		return m.Executions
	}
	return nil
}

type AgentRunRequest struct {
	Job                  *Job       `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Execution            *Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AgentRunRequest) Reset()         { *m = AgentRunRequest{} }
func (m *AgentRunRequest) String() string { return proto.CompactTextString(m) }
func (*AgentRunRequest) ProtoMessage()    {}
func (*AgentRunRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f956fb9152fd788f, []int{21}
}
func (m *AgentRunRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentRunRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentRunRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentRunRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentRunRequest.Merge(m, src)
}
func (m *AgentRunRequest) XXX_Size() int {
	return m.Size()
}
func (m *AgentRunRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentRunRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AgentRunRequest proto.InternalMessageInfo

func (m *AgentRunRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *AgentRunRequest) GetExecution() *Execution {
	if m != nil {
		return m.Execution
	}
	return nil
}

func init() {
	proto.RegisterType((*Job)(nil), "types.Job")
	proto.RegisterMapType((map[string]string)(nil), "types.Job.ExecutorConfigEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.Job.MetadataEntry")
	proto.RegisterMapType((map[string]*PluginConfig)(nil), "types.Job.ProcessorsEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.Job.TagsEntry")
	proto.RegisterType((*Job_NullableTime)(nil), "types.Job.NullableTime")
	proto.RegisterType((*PluginConfig)(nil), "types.PluginConfig")
	proto.RegisterMapType((map[string]string)(nil), "types.PluginConfig.ConfigEntry")
	proto.RegisterType((*SetJobRequest)(nil), "types.SetJobRequest")
	proto.RegisterType((*SetJobResponse)(nil), "types.SetJobResponse")
	proto.RegisterType((*DeleteJobRequest)(nil), "types.DeleteJobRequest")
	proto.RegisterType((*DeleteJobResponse)(nil), "types.DeleteJobResponse")
	proto.RegisterType((*GetJobRequest)(nil), "types.GetJobRequest")
	proto.RegisterType((*GetJobResponse)(nil), "types.GetJobResponse")
	proto.RegisterType((*Execution)(nil), "types.Execution")
	proto.RegisterType((*ExecutionDoneRequest)(nil), "types.ExecutionDoneRequest")
	proto.RegisterType((*ExecutionDoneResponse)(nil), "types.ExecutionDoneResponse")
	proto.RegisterType((*RunJobRequest)(nil), "types.RunJobRequest")
	proto.RegisterType((*RunJobResponse)(nil), "types.RunJobResponse")
	proto.RegisterType((*ToggleJobRequest)(nil), "types.ToggleJobRequest")
	proto.RegisterType((*ToggleJobResponse)(nil), "types.ToggleJobResponse")
	proto.RegisterType((*RaftServer)(nil), "types.RaftServer")
	proto.RegisterType((*RaftGetConfigurationResponse)(nil), "types.RaftGetConfigurationResponse")
	proto.RegisterType((*RaftRemovePeerByIDRequest)(nil), "types.RaftRemovePeerByIDRequest")
	proto.RegisterType((*AgentRunStream)(nil), "types.AgentRunStream")
	proto.RegisterType((*AgentRunResponse)(nil), "types.AgentRunResponse")
	proto.RegisterType((*GetActiveExecutionsResponse)(nil), "types.GetActiveExecutionsResponse")
	proto.RegisterType((*AgentRunRequest)(nil), "types.AgentRunRequest")
}

func init() { proto.RegisterFile("spiderjob.proto", fileDescriptor_f956fb9152fd788f) }

var fileDescriptor_f956fb9152fd788f = []byte{
	// 1374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xdd, 0x72, 0xdb, 0xb6,
	0x12, 0x3e, 0x94, 0x2c, 0x5b, 0x5c, 0xfd, 0xd8, 0x81, 0x9d, 0x84, 0xa1, 0x73, 0x1c, 0x1d, 0x65,
	0xce, 0x8c, 0xce, 0xc9, 0x84, 0x4e, 0xdd, 0xa6, 0xf9, 0x9b, 0xc9, 0xc4, 0x89, 0x5d, 0x4f, 0x3d,
	0x6d, 0xea, 0x52, 0x9e, 0x5e, 0xb4, 0x17, 0x1a, 0x48, 0x5c, 0xcb, 0x74, 0x29, 0x82, 0x25, 0x40,
	0x37, 0xea, 0x65, 0x9f, 0xa2, 0x37, 0x7d, 0x8c, 0xbe, 0x43, 0x2f, 0xfb, 0x08, 0x9d, 0xf4, 0xa2,
	0xaf, 0xd1, 0x01, 0x40, 0xd2, 0x94, 0x2c, 0xf9, 0x27, 0x77, 0xd8, 0xc5, 0x87, 0xc5, 0xfe, 0x7c,
	0xbb, 0x00, 0x2c, 0xf3, 0xc8, 0xf7, 0x30, 0x3e, 0x61, 0x7d, 0x27, 0x8a, 0x99, 0x60, 0xa4, 0x22,
	0xc6, 0x11, 0x72, 0xfb, 0xde, 0x90, 0xb1, 0x61, 0x80, 0x9b, 0x4a, 0xd9, 0x4f, 0x8e, 0x36, 0x85,
	0x3f, 0x42, 0x2e, 0xe8, 0x28, 0xd2, 0x38, 0x7b, 0x7d, 0x1a, 0x80, 0xa3, 0x48, 0x8c, 0xf5, 0x66,
	0xfb, 0x37, 0x13, 0xca, 0xfb, 0xac, 0x4f, 0x08, 0x2c, 0x84, 0x74, 0x84, 0x96, 0xd1, 0x32, 0x3a,
	0xa6, 0xab, 0xd6, 0xc4, 0x86, 0xaa, 0xb4, 0xf5, 0x13, 0x0b, 0xd1, 0x2a, 0x29, 0x7d, 0x2e, 0xcb,
	0x3d, 0x3e, 0x38, 0x46, 0x2f, 0x09, 0xd0, 0x2a, 0xeb, 0xbd, 0x4c, 0x26, 0x6b, 0x50, 0x61, 0x3f,
	0x86, 0x18, 0x5b, 0x4b, 0x6a, 0x43, 0x0b, 0xe4, 0x1e, 0xd4, 0xd4, 0xa2, 0x87, 0x23, 0xea, 0x07,
	0x56, 0x55, 0xed, 0x81, 0x52, 0xed, 0x4a, 0x0d, 0xb9, 0x0f, 0x0d, 0x9e, 0x0c, 0x06, 0xc8, 0x79,
	0x6f, 0xc0, 0x92, 0x50, 0x58, 0x66, 0xcb, 0xe8, 0x54, 0xdc, 0x7a, 0xaa, 0x7c, 0x23, 0x75, 0xd2,
	0x0a, 0xc6, 0x31, 0x8b, 0x53, 0x08, 0x28, 0x08, 0x28, 0x95, 0x06, 0xd8, 0x50, 0xf5, 0x7c, 0x4e,
	0xfb, 0x01, 0x7a, 0x56, 0xad, 0x65, 0x74, 0xaa, 0x6e, 0x2e, 0x93, 0x0e, 0x2c, 0x08, 0x3a, 0xe4,
	0x56, 0xbd, 0x55, 0xee, 0xd4, 0xb6, 0xd6, 0x1c, 0x95, 0x40, 0x67, 0x9f, 0xf5, 0x9d, 0x43, 0x3a,
	0xe4, 0xbb, 0xa1, 0x88, 0xc7, 0xae, 0x42, 0x10, 0x0b, 0x96, 0x62, 0x14, 0xb1, 0x8f, 0xdc, 0x6a,
	0xb4, 0x8c, 0x4e, 0xc3, 0xcd, 0x44, 0xf2, 0x5f, 0x68, 0x7a, 0x18, 0x61, 0xe8, 0x61, 0x28, 0x7a,
	0x27, 0xac, 0xcf, 0xad, 0x66, 0xab, 0xdc, 0x31, 0xdd, 0x46, 0xae, 0xdd, 0x67, 0x7d, 0x4e, 0xfe,
	0x0d, 0x10, 0xd1, 0x38, 0xc5, 0x58, 0xcb, 0x2a, 0x58, 0x53, 0x6b, 0x64, 0xba, 0x5b, 0x50, 0x1b,
	0xb0, 0x70, 0x90, 0xc4, 0x31, 0x86, 0x83, 0xb1, 0xb5, 0xa2, 0xf6, 0x8b, 0x2a, 0x19, 0x07, 0xbe,
	0xc3, 0x41, 0x22, 0x58, 0x6c, 0xdd, 0xd0, 0x09, 0xce, 0x64, 0xb2, 0x07, 0xcb, 0xd9, 0xba, 0x37,
	0x60, 0xe1, 0x91, 0x3f, 0xb4, 0x88, 0x0a, 0x69, 0xa3, 0x10, 0xd2, 0x6e, 0x8a, 0x78, 0xa3, 0x00,
	0x3a, 0xb8, 0x26, 0x4e, 0x28, 0xc9, 0x2d, 0x58, 0xe4, 0x82, 0x8a, 0x84, 0x5b, 0xab, 0xea, 0x8a,
	0x54, 0x22, 0x9f, 0x40, 0x75, 0x84, 0x82, 0x7a, 0x54, 0x50, 0x6b, 0x4d, 0x59, 0xb6, 0x0a, 0x96,
	0xbf, 0x4c, 0xb7, 0xb4, 0xcd, 0x1c, 0x49, 0x9e, 0x43, 0x3d, 0xa0, 0x5c, 0xf4, 0xd2, 0x82, 0x59,
	0x77, 0x5a, 0x46, 0xa7, 0xb6, 0x75, 0xbb, 0x70, 0xf2, 0x6d, 0x12, 0x04, 0xb2, 0x14, 0x87, 0xfe,
	0x08, 0xdd, 0x9a, 0x04, 0x77, 0x35, 0x96, 0x7c, 0x0a, 0xa0, 0xce, 0xaa, 0x4a, 0x5a, 0xf6, 0xc5,
	0x27, 0x4d, 0x09, 0xdd, 0x95, 0x48, 0xe2, 0xc0, 0x42, 0x88, 0xef, 0x84, 0x75, 0x5b, 0x9d, 0xb0,
	0x1d, 0xcd, 0x75, 0x27, 0xe3, 0xba, 0x73, 0x98, 0x35, 0x83, 0xab, 0x70, 0x32, 0xf1, 0x9e, 0xcf,
	0xa3, 0x80, 0x8e, 0x15, 0xdd, 0x2d, 0x9d, 0xf8, 0x82, 0x8a, 0x3c, 0x07, 0x88, 0x62, 0x26, 0x9d,
	0x62, 0x31, 0xb7, 0xd6, 0x55, 0xf4, 0x76, 0xc1, 0x93, 0x83, 0x7c, 0x53, 0xc7, 0x5f, 0x40, 0xdb,
	0x4f, 0xc0, 0xcc, 0x99, 0x44, 0x56, 0xa0, 0xfc, 0x3d, 0x8e, 0xd3, 0x8e, 0x92, 0x4b, 0xd9, 0x18,
	0xa7, 0x34, 0x48, 0xb2, 0x6e, 0xd2, 0xc2, 0xf3, 0xd2, 0x53, 0xc3, 0xde, 0x86, 0xd5, 0x19, 0xf5,
	0xba, 0x96, 0x89, 0x17, 0xd0, 0x98, 0x28, 0xcc, 0xb5, 0x0e, 0x7f, 0x07, 0xf5, 0x62, 0x86, 0xc9,
	0x3a, 0x98, 0xc7, 0x94, 0xf7, 0x34, 0xda, 0xd0, 0x6d, 0x74, 0x4c, 0xf9, 0x37, 0x52, 0x96, 0x39,
	0x97, 0x73, 0x40, 0x59, 0xb9, 0x24, 0xe7, 0x12, 0x67, 0xbb, 0xb0, 0x3c, 0x95, 0xb4, 0x19, 0xbe,
	0xfd, 0xaf, 0xe8, 0x5b, 0x6d, 0x6b, 0x35, 0xcd, 0xf8, 0x41, 0x90, 0x0c, 0xfd, 0x50, 0xe7, 0xa4,
	0xe0, 0x70, 0xfb, 0x67, 0x03, 0xea, 0xc5, 0x3d, 0xf2, 0x04, 0x16, 0xd3, 0x56, 0x30, 0x54, 0xc9,
	0xee, 0xcd, 0x30, 0xe0, 0x14, 0x7b, 0x21, 0x85, 0xdb, 0xcf, 0xa0, 0xf6, 0x81, 0x29, 0x6f, 0x3f,
	0x84, 0x46, 0x17, 0x65, 0x3f, 0xbb, 0xf8, 0x43, 0x82, 0x5c, 0x90, 0xbb, 0x50, 0x96, 0xed, 0x6e,
	0xa8, 0x10, 0xe0, 0x8c, 0x34, 0xae, 0x54, 0xb7, 0x1d, 0x68, 0x66, 0x70, 0x1e, 0xb1, 0x90, 0xe3,
	0x25, 0xf8, 0x87, 0xb0, 0xb2, 0x83, 0x01, 0x0a, 0x2c, 0xdc, 0x70, 0x07, 0xaa, 0x27, 0xac, 0xdf,
	0x2b, 0xcc, 0xea, 0xa5, 0x13, 0xd6, 0x7f, 0x4b, 0x47, 0xd8, 0xfe, 0x08, 0x6e, 0x14, 0xe0, 0x57,
	0xba, 0xe1, 0xff, 0xd0, 0xd8, 0x9b, 0x08, 0xe0, 0x02, 0xf3, 0x0e, 0x34, 0xf7, 0xae, 0xe3, 0xfd,
	0xaf, 0x25, 0x30, 0x35, 0xa7, 0x7d, 0x16, 0x5e, 0x60, 0x58, 0xce, 0xda, 0x6c, 0x62, 0x94, 0x14,
	0xd3, 0x32, 0x51, 0x8e, 0x27, 0x96, 0x88, 0x28, 0x11, 0xea, 0x89, 0xa9, 0xbb, 0xa9, 0x24, 0xd9,
	0x19, 0x32, 0x0f, 0xb5, 0xb5, 0x05, 0x3d, 0x1c, 0xa5, 0x42, 0x99, 0x5b, 0x83, 0xca, 0x30, 0x66,
	0x49, 0x64, 0x55, 0x5a, 0x46, 0xa7, 0xec, 0x6a, 0x41, 0x5e, 0x42, 0x85, 0x90, 0x2f, 0x9f, 0xb5,
	0xa8, 0x07, 0x7a, 0x2a, 0x92, 0x67, 0x00, 0x5c, 0xd0, 0x58, 0xa0, 0xd7, 0xa3, 0x42, 0x3d, 0x59,
	0x17, 0x73, 0xda, 0x4c, 0xd1, 0xdb, 0x82, 0xbc, 0x80, 0xda, 0x91, 0x1f, 0xfa, 0xfc, 0x58, 0x9f,
	0xad, 0x5e, 0x7a, 0x16, 0x32, 0xf8, 0xb6, 0x68, 0x7f, 0x06, 0x6b, 0x79, 0x7a, 0x76, 0x58, 0x88,
	0x59, 0x09, 0x1c, 0x30, 0x31, 0xd3, 0xa7, 0xb9, 0x5d, 0x49, 0x73, 0x9b, 0xe3, 0xdd, 0x33, 0x48,
	0x7b, 0x17, 0x6e, 0x4e, 0xd9, 0x49, 0xcb, 0x43, 0x60, 0xe1, 0x28, 0x66, 0xa3, 0xec, 0x49, 0x97,
	0x6b, 0x99, 0x86, 0x88, 0x8e, 0x03, 0x46, 0x3d, 0x95, 0xeb, 0xba, 0x9b, 0x89, 0x92, 0x0a, 0x6e,
	0x12, 0x5e, 0x99, 0x0a, 0x19, 0xf6, 0xaa, 0x44, 0x3e, 0x64, 0xc3, 0x61, 0x70, 0x75, 0x22, 0x17,
	0xe0, 0x57, 0x23, 0x9b, 0x01, 0xe0, 0xd2, 0x23, 0xd1, 0xc5, 0xf8, 0x14, 0x63, 0xd2, 0x84, 0x92,
	0xef, 0xa5, 0x66, 0x4b, 0xbe, 0xa7, 0x7e, 0x37, 0xcc, 0xcb, 0x3a, 0x58, 0xad, 0x15, 0x23, 0x3c,
	0x2f, 0x96, 0xb4, 0xd3, 0x1f, 0x98, 0x4c, 0x94, 0xb4, 0x0b, 0x90, 0x7a, 0x18, 0x2b, 0x6e, 0x55,
	0xdd, 0x54, 0x52, 0x83, 0x80, 0x09, 0x8c, 0x15, 0xb3, 0xaa, 0xae, 0x16, 0xe4, 0xb7, 0x25, 0xa6,
	0x47, 0xa2, 0xa7, 0xca, 0x3d, 0x60, 0x81, 0xe2, 0x97, 0xe9, 0xd6, 0xa5, 0xf2, 0x20, 0xd5, 0xb5,
	0x29, 0xdc, 0x95, 0xee, 0xed, 0xa1, 0xd0, 0xb3, 0x26, 0x89, 0xa9, 0xaa, 0x63, 0x16, 0xdd, 0x03,
	0x58, 0xe2, 0xca, 0x75, 0x9e, 0x8e, 0xaf, 0x1b, 0x69, 0x84, 0x67, 0x41, 0xb9, 0x19, 0x42, 0xfa,
	0xe1, 0x87, 0x1e, 0xbe, 0x53, 0xe1, 0x2c, 0xb8, 0x5a, 0x68, 0x3f, 0x80, 0x3b, 0x12, 0xec, 0xe2,
	0x88, 0x9d, 0xe2, 0x01, 0x62, 0xfc, 0x7a, 0xfc, 0xf9, 0x4e, 0x96, 0xed, 0xa9, 0x84, 0xb4, 0x5f,
	0x41, 0x73, 0x7b, 0x88, 0xa1, 0x70, 0x93, 0xb0, 0x2b, 0x62, 0xa4, 0xa3, 0x6b, 0xd3, 0xee, 0x15,
	0xac, 0x64, 0x16, 0x3e, 0x90, 0x71, 0x5f, 0xc1, 0xfa, 0x1e, 0x8a, 0xed, 0x81, 0xf0, 0x4f, 0x31,
	0xbf, 0x82, 0xe7, 0xc6, 0x1e, 0x01, 0xe4, 0xb7, 0x65, 0x59, 0x39, 0xef, 0x51, 0x01, 0xd3, 0xee,
	0xc1, 0xf2, 0x99, 0x4b, 0x57, 0x18, 0xc8, 0x93, 0x31, 0x97, 0x2e, 0x8d, 0x79, 0xeb, 0xef, 0x0a,
	0x98, 0xdd, 0xec, 0x17, 0x4e, 0x1e, 0xc3, 0xa2, 0x1e, 0x88, 0x24, 0xfb, 0x49, 0x4e, 0xcc, 0x52,
	0xfb, 0xe6, 0x94, 0x36, 0x8d, 0x6b, 0x1f, 0x1a, 0x13, 0xfd, 0x4a, 0xd6, 0xa7, 0xaf, 0x2c, 0x4c,
	0x03, 0xfb, 0xee, 0xec, 0xcd, 0xd4, 0xd6, 0x13, 0xa8, 0x7c, 0x81, 0xf4, 0x14, 0xc9, 0xad, 0x73,
	0x43, 0x67, 0x57, 0x7e, 0xf2, 0xed, 0x39, 0x7a, 0xe9, 0x7b, 0x77, 0xd2, 0xf7, 0xee, 0x4c, 0xdf,
	0xa7, 0xde, 0xab, 0x97, 0x60, 0xe6, 0x4f, 0x0c, 0xc9, 0xbe, 0x67, 0xd3, 0x6f, 0x94, 0x6d, 0x9d,
	0xdf, 0x48, 0xcf, 0x3f, 0x86, 0x45, 0x3d, 0x38, 0xf2, 0x6b, 0x27, 0x66, 0x4e, 0x7e, 0xed, 0xd4,
	0x74, 0x79, 0x09, 0x66, 0x3e, 0x10, 0xf2, 0x6b, 0xa7, 0x27, 0x4a, 0x7e, 0xed, 0xf9, 0xd9, 0xd1,
	0x85, 0xb5, 0x59, 0xdd, 0x37, 0x37, 0x6b, 0xf7, 0x0b, 0xcd, 0x37, 0xb7, 0x65, 0xdf, 0x02, 0x39,
	0xdf, 0x6f, 0xa4, 0x55, 0x38, 0x3a, 0xb3, 0x15, 0xe7, 0x96, 0xe4, 0x6b, 0x58, 0x9d, 0xd1, 0x0e,
	0x73, 0x7d, 0x6c, 0x9f, 0xb1, 0x6b, 0x6e, 0x0b, 0x3d, 0x85, 0x7a, 0x17, 0xc5, 0xd9, 0x23, 0x7c,
	0x8e, 0xdc, 0xf3, 0x9c, 0xd9, 0xda, 0x81, 0x8a, 0x6a, 0x25, 0xf2, 0x02, 0xaa, 0x59, 0x4f, 0x91,
	0x5b, 0xe9, 0xf1, 0xa9, 0x26, 0xcb, 0xab, 0x36, 0x39, 0x51, 0x1e, 0x19, 0xaf, 0xff, 0xf3, 0xfb,
	0xfb, 0x0d, 0xe3, 0x8f, 0xf7, 0x1b, 0xc6, 0x9f, 0xef, 0x37, 0x8c, 0x5f, 0xfe, 0xda, 0xf8, 0xd7,
	0xb7, 0xcb, 0x8e, 0xb3, 0x19, 0xa9, 0x1f, 0xd9, 0xa6, 0x3a, 0xd3, 0x5f, 0x54, 0x17, 0x7f, 0xfc,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6e, 0xa4, 0x84, 0xdd, 0xde, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SpiderjobClient is the client API for Spiderjob service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SpiderjobClient interface {
	GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error)
	ExecutionDone(ctx context.Context, in *ExecutionDoneRequest, opts ...grpc.CallOption) (*ExecutionDoneResponse, error)
	Leave(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*protobuf.Empty, error)
	SetJob(ctx context.Context, in *SetJobRequest, opts ...grpc.CallOption) (*SetJobResponse, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error)
	RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error)
	ToggleJob(ctx context.Context, in *ToggleJobRequest, opts ...grpc.CallOption) (*ToggleJobResponse, error)
	RaftGetConfiguration(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*RaftGetConfigurationResponse, error)
	RaftRemovePeerByID(ctx context.Context, in *RaftRemovePeerByIDRequest, opts ...grpc.CallOption) (*protobuf.Empty, error)
	GetActiveExecutions(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*GetActiveExecutionsResponse, error)
	SetExecution(ctx context.Context, in *Execution, opts ...grpc.CallOption) (*protobuf.Empty, error)
}

type spiderjobClient struct {
	cc *grpc.ClientConn
}

func NewSpiderjobClient(cc *grpc.ClientConn) SpiderjobClient {
	return &spiderjobClient{cc}
}

func (c *spiderjobClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...grpc.CallOption) (*GetJobResponse, error) {
	out := new(GetJobResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/GetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) ExecutionDone(ctx context.Context, in *ExecutionDoneRequest, opts ...grpc.CallOption) (*ExecutionDoneResponse, error) {
	out := new(ExecutionDoneResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/ExecutionDone", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) Leave(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*protobuf.Empty, error) {
	out := new(protobuf.Empty)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/Leave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) SetJob(ctx context.Context, in *SetJobRequest, opts ...grpc.CallOption) (*SetJobResponse, error) {
	out := new(SetJobResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/SetJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error) {
	out := new(DeleteJobResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/DeleteJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) RunJob(ctx context.Context, in *RunJobRequest, opts ...grpc.CallOption) (*RunJobResponse, error) {
	out := new(RunJobResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/RunJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) ToggleJob(ctx context.Context, in *ToggleJobRequest, opts ...grpc.CallOption) (*ToggleJobResponse, error) {
	out := new(ToggleJobResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/ToggleJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) RaftGetConfiguration(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*RaftGetConfigurationResponse, error) {
	out := new(RaftGetConfigurationResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/RaftGetConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) RaftRemovePeerByID(ctx context.Context, in *RaftRemovePeerByIDRequest, opts ...grpc.CallOption) (*protobuf.Empty, error) {
	out := new(protobuf.Empty)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/RaftRemovePeerByID", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) GetActiveExecutions(ctx context.Context, in *protobuf.Empty, opts ...grpc.CallOption) (*GetActiveExecutionsResponse, error) {
	out := new(GetActiveExecutionsResponse)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/GetActiveExecutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *spiderjobClient) SetExecution(ctx context.Context, in *Execution, opts ...grpc.CallOption) (*protobuf.Empty, error) {
	out := new(protobuf.Empty)
	err := c.cc.Invoke(ctx, "/types.Spiderjob/SetExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SpiderjobServer is the server API for Spiderjob service.
type SpiderjobServer interface {
	GetJob(context.Context, *GetJobRequest) (*GetJobResponse, error)
	ExecutionDone(context.Context, *ExecutionDoneRequest) (*ExecutionDoneResponse, error)
	Leave(context.Context, *protobuf.Empty) (*protobuf.Empty, error)
	SetJob(context.Context, *SetJobRequest) (*SetJobResponse, error)
	DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error)
	RunJob(context.Context, *RunJobRequest) (*RunJobResponse, error)
	ToggleJob(context.Context, *ToggleJobRequest) (*ToggleJobResponse, error)
	RaftGetConfiguration(context.Context, *protobuf.Empty) (*RaftGetConfigurationResponse, error)
	RaftRemovePeerByID(context.Context, *RaftRemovePeerByIDRequest) (*protobuf.Empty, error)
	GetActiveExecutions(context.Context, *protobuf.Empty) (*GetActiveExecutionsResponse, error)
	SetExecution(context.Context, *Execution) (*protobuf.Empty, error)
}

// UnimplementedSpiderjobServer can be embedded to have forward compatible implementations.
type UnimplementedSpiderjobServer struct {
}

func (*UnimplementedSpiderjobServer) GetJob(ctx context.Context, req *GetJobRequest) (*GetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (*UnimplementedSpiderjobServer) ExecutionDone(ctx context.Context, req *ExecutionDoneRequest) (*ExecutionDoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecutionDone not implemented")
}
func (*UnimplementedSpiderjobServer) Leave(ctx context.Context, req *protobuf.Empty) (*protobuf.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Leave not implemented")
}
func (*UnimplementedSpiderjobServer) SetJob(ctx context.Context, req *SetJobRequest) (*SetJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetJob not implemented")
}
func (*UnimplementedSpiderjobServer) DeleteJob(ctx context.Context, req *DeleteJobRequest) (*DeleteJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (*UnimplementedSpiderjobServer) RunJob(ctx context.Context, req *RunJobRequest) (*RunJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunJob not implemented")
}
func (*UnimplementedSpiderjobServer) ToggleJob(ctx context.Context, req *ToggleJobRequest) (*ToggleJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ToggleJob not implemented")
}
func (*UnimplementedSpiderjobServer) RaftGetConfiguration(ctx context.Context, req *protobuf.Empty) (*RaftGetConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaftGetConfiguration not implemented")
}
func (*UnimplementedSpiderjobServer) RaftRemovePeerByID(ctx context.Context, req *RaftRemovePeerByIDRequest) (*protobuf.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RaftRemovePeerByID not implemented")
}
func (*UnimplementedSpiderjobServer) GetActiveExecutions(ctx context.Context, req *protobuf.Empty) (*GetActiveExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveExecutions not implemented")
}
func (*UnimplementedSpiderjobServer) SetExecution(ctx context.Context, req *Execution) (*protobuf.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetExecution not implemented")
}

func RegisterSpiderjobServer(s *grpc.Server, srv SpiderjobServer) {
	s.RegisterService(&_Spiderjob_serviceDesc, srv)
}

func _Spiderjob_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).GetJob(ctx, req.(*GetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_ExecutionDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecutionDoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).ExecutionDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/ExecutionDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).ExecutionDone(ctx, req.(*ExecutionDoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/Leave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).Leave(ctx, req.(*protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_SetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).SetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/SetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).SetJob(ctx, req.(*SetJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_RunJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).RunJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/RunJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).RunJob(ctx, req.(*RunJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_ToggleJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ToggleJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).ToggleJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/ToggleJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).ToggleJob(ctx, req.(*ToggleJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_RaftGetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).RaftGetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/RaftGetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).RaftGetConfiguration(ctx, req.(*protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_RaftRemovePeerByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftRemovePeerByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).RaftRemovePeerByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/RaftRemovePeerByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).RaftRemovePeerByID(ctx, req.(*RaftRemovePeerByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_GetActiveExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).GetActiveExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/GetActiveExecutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).GetActiveExecutions(ctx, req.(*protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Spiderjob_SetExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Execution)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SpiderjobServer).SetExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/types.Spiderjob/SetExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SpiderjobServer).SetExecution(ctx, req.(*Execution))
	}
	return interceptor(ctx, in, info, handler)
}

var _Spiderjob_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.Spiderjob",
	HandlerType: (*SpiderjobServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetJob",
			Handler:    _Spiderjob_GetJob_Handler,
		},
		{
			MethodName: "ExecutionDone",
			Handler:    _Spiderjob_ExecutionDone_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _Spiderjob_Leave_Handler,
		},
		{
			MethodName: "SetJob",
			Handler:    _Spiderjob_SetJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _Spiderjob_DeleteJob_Handler,
		},
		{
			MethodName: "RunJob",
			Handler:    _Spiderjob_RunJob_Handler,
		},
		{
			MethodName: "ToggleJob",
			Handler:    _Spiderjob_ToggleJob_Handler,
		},
		{
			MethodName: "RaftGetConfiguration",
			Handler:    _Spiderjob_RaftGetConfiguration_Handler,
		},
		{
			MethodName: "RaftRemovePeerByID",
			Handler:    _Spiderjob_RaftRemovePeerByID_Handler,
		},
		{
			MethodName: "GetActiveExecutions",
			Handler:    _Spiderjob_GetActiveExecutions_Handler,
		},
		{
			MethodName: "SetExecution",
			Handler:    _Spiderjob_SetExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spiderjob.proto",
}

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AgentClient interface {
	AgentRun(ctx context.Context, in *AgentRunRequest, opts ...grpc.CallOption) (Agent_AgentRunClient, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) AgentRun(ctx context.Context, in *AgentRunRequest, opts ...grpc.CallOption) (Agent_AgentRunClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Agent_serviceDesc.Streams[0], "/types.Agent/AgentRun", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentAgentRunClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_AgentRunClient interface {
	Recv() (*AgentRunStream, error)
	grpc.ClientStream
}

type agentAgentRunClient struct {
	grpc.ClientStream
}

func (x *agentAgentRunClient) Recv() (*AgentRunStream, error) {
	m := new(AgentRunStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AgentServer is the server API for Agent service.
type AgentServer interface {
	AgentRun(*AgentRunRequest, Agent_AgentRunServer) error
}

// UnimplementedAgentServer can be embedded to have forward compatible implementations.
type UnimplementedAgentServer struct {
}

func (*UnimplementedAgentServer) AgentRun(req *AgentRunRequest, srv Agent_AgentRunServer) error {
	return status.Errorf(codes.Unimplemented, "method AgentRun not implemented")
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_AgentRun_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AgentRunRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).AgentRun(m, &agentAgentRunServer{stream})
}

type Agent_AgentRunServer interface {
	Send(*AgentRunStream) error
	grpc.ServerStream
}

type agentAgentRunServer struct {
	grpc.ServerStream
}

func (x *agentAgentRunServer) Send(m *AgentRunStream) error {
	return x.ServerStream.SendMsg(m)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AgentRun",
			Handler:       _Agent_AgentRun_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "spiderjob.proto",
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Processors) > 0 {
		for k := range m.Processors {
			v := m.Processors[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSpiderjob(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpiderjob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xda
		}
	}
	if m.LastError != nil {
		{
			size, err := m.LastError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.LastSuccess != nil {
		{
			size, err := m.LastSuccess.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if len(m.Displayname) > 0 {
		i -= len(m.Displayname)
		copy(dAtA[i:], m.Displayname)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Displayname)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Next != nil {
		{
			size, err := m.Next.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpiderjob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xa2
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.ExecutorConfig) > 0 {
		for k := range m.ExecutorConfig {
			v := m.ExecutorConfig[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpiderjob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.Executor) > 0 {
		i -= len(m.Executor)
		copy(dAtA[i:], m.Executor)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Executor)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Concurrency) > 0 {
		i -= len(m.Concurrency)
		copy(dAtA[i:], m.Concurrency)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Concurrency)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.ParentJob) > 0 {
		i -= len(m.ParentJob)
		copy(dAtA[i:], m.ParentJob)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.ParentJob)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.DependentJobs) > 0 {
		for iNdEx := len(m.DependentJobs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DependentJobs[iNdEx])
			copy(dAtA[i:], m.DependentJobs[iNdEx])
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.DependentJobs[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.Retries != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Tags) > 0 {
		for k := range m.Tags {
			v := m.Tags[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpiderjob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.Disabled {
		i--
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ErrorCount != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.ErrorCount))
		i--
		dAtA[i] = 0x50
	}
	if m.SuccessCount != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.SuccessCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.OwnerEmail) > 0 {
		i -= len(m.OwnerEmail)
		copy(dAtA[i:], m.OwnerEmail)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.OwnerEmail)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Schedule) > 0 {
		i -= len(m.Schedule)
		copy(dAtA[i:], m.Schedule)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Schedule)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Timezone) > 0 {
		i -= len(m.Timezone)
		copy(dAtA[i:], m.Timezone)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Timezone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Job_NullableTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job_NullableTime) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job_NullableTime) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Time != nil {
		{
			size, err := m.Time.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HasValue {
		i--
		if m.HasValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PluginConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PluginConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PluginConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		for k := range m.Config {
			v := m.Config[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSpiderjob(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSpiderjob(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SetJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JobName) > 0 {
		i -= len(m.JobName)
		copy(dAtA[i:], m.JobName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.JobName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JobName) > 0 {
		i -= len(m.JobName)
		copy(dAtA[i:], m.JobName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.JobName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FinishedAt != nil {
		{
			size, err := m.FinishedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.StartedAt != nil {
		{
			size, err := m.StartedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Attempt != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.Attempt))
		i--
		dAtA[i] = 0x30
	}
	if m.Group != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Output) > 0 {
		i -= len(m.Output)
		copy(dAtA[i:], m.Output)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Output)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.JobName) > 0 {
		i -= len(m.JobName)
		copy(dAtA[i:], m.JobName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.JobName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionDoneRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionDoneRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionDoneRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Execution != nil {
		{
			size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionDoneResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionDoneResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionDoneResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JobName) > 0 {
		i -= len(m.JobName)
		copy(dAtA[i:], m.JobName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.JobName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ToggleJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToggleJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToggleJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JobName) > 0 {
		i -= len(m.JobName)
		copy(dAtA[i:], m.JobName)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.JobName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ToggleJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ToggleJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ToggleJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RaftProtocol) > 0 {
		i -= len(m.RaftProtocol)
		copy(dAtA[i:], m.RaftProtocol)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.RaftProtocol)))
		i--
		dAtA[i] = 0x32
	}
	if m.Voter {
		i--
		if m.Voter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Leader {
		i--
		if m.Leader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Node) > 0 {
		i -= len(m.Node)
		copy(dAtA[i:], m.Node)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Node)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftGetConfigurationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftGetConfigurationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftGetConfigurationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintSpiderjob(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Servers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpiderjob(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RaftRemovePeerByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRemovePeerByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRemovePeerByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AgentRunStream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentRunStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentRunStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Execution != nil {
		{
			size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AgentRunResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentRunResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentRunResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintSpiderjob(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetActiveExecutionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetActiveExecutionsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetActiveExecutionsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Executions) > 0 {
		for iNdEx := len(m.Executions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Executions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSpiderjob(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AgentRunRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentRunRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AgentRunRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Execution != nil {
		{
			size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSpiderjob(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSpiderjob(dAtA []byte, offset int, v uint64) int {
	offset -= sovSpiderjob(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Timezone)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Schedule)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.OwnerEmail)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.SuccessCount != 0 {
		n += 1 + sovSpiderjob(uint64(m.SuccessCount))
	}
	if m.ErrorCount != 0 {
		n += 1 + sovSpiderjob(uint64(m.ErrorCount))
	}
	if m.Disabled {
		n += 2
	}
	if len(m.Tags) > 0 {
		for k, v := range m.Tags {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSpiderjob(uint64(len(k))) + 1 + len(v) + sovSpiderjob(uint64(len(v)))
			n += mapEntrySize + 1 + sovSpiderjob(uint64(mapEntrySize))
		}
	}
	if m.Retries != 0 {
		n += 1 + sovSpiderjob(uint64(m.Retries))
	}
	if len(m.DependentJobs) > 0 {
		for _, s := range m.DependentJobs {
			l = len(s)
			n += 1 + l + sovSpiderjob(uint64(l))
		}
	}
	l = len(m.ParentJob)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Concurrency)
	if l > 0 {
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Executor)
	if l > 0 {
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	if len(m.ExecutorConfig) > 0 {
		for k, v := range m.ExecutorConfig {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSpiderjob(uint64(len(k))) + 1 + len(v) + sovSpiderjob(uint64(len(v)))
			n += mapEntrySize + 2 + sovSpiderjob(uint64(mapEntrySize))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSpiderjob(uint64(len(k))) + 1 + len(v) + sovSpiderjob(uint64(len(v)))
			n += mapEntrySize + 2 + sovSpiderjob(uint64(mapEntrySize))
		}
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Displayname)
	if l > 0 {
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	if m.LastSuccess != nil {
		l = m.LastSuccess.Size()
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	if m.LastError != nil {
		l = m.LastError.Size()
		n += 2 + l + sovSpiderjob(uint64(l))
	}
	if len(m.Processors) > 0 {
		for k, v := range m.Processors {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSpiderjob(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSpiderjob(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovSpiderjob(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Job_NullableTime) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasValue {
		n += 2
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PluginConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSpiderjob(uint64(len(k))) + 1 + len(v) + sovSpiderjob(uint64(len(v)))
			n += mapEntrySize + 1 + sovSpiderjob(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.Success {
		n += 2
	}
	l = len(m.Output)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovSpiderjob(uint64(m.Group))
	}
	if m.Attempt != 0 {
		n += 1 + sovSpiderjob(uint64(m.Attempt))
	}
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.FinishedAt != nil {
		l = m.FinishedAt.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutionDoneRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execution != nil {
		l = m.Execution.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecutionDoneResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ToggleJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobName)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ToggleJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Node)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.Leader {
		n += 2
	}
	if m.Voter {
		n += 2
	}
	l = len(m.RaftProtocol)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftGetConfigurationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovSpiderjob(uint64(l))
		}
	}
	if m.Index != 0 {
		n += 1 + sovSpiderjob(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftRemovePeerByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentRunStream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Execution != nil {
		l = m.Execution.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentRunResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetActiveExecutionsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Executions) > 0 {
		for _, e := range m.Executions {
			l = e.Size()
			n += 1 + l + sovSpiderjob(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentRunRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.Execution != nil {
		l = m.Execution.Size()
		n += 1 + l + sovSpiderjob(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSpiderjob(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSpiderjob(x uint64) (n int) {
	return sovSpiderjob(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timezone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schedule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessCount", wireType)
			}
			m.SuccessCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SuccessCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount", wireType)
			}
			m.ErrorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tags == nil {
				m.Tags = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpiderjob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpiderjob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tags[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DependentJobs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DependentJobs = append(m.DependentJobs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentJob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentJob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Concurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutorConfig == nil {
				m.ExecutorConfig = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpiderjob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpiderjob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ExecutorConfig[mapkey] = mapvalue
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpiderjob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpiderjob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &protobuf.Timestamp{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Displayname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Displayname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSuccess", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastSuccess == nil {
				m.LastSuccess = &Job_NullableTime{}
			}
			if err := m.LastSuccess.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastError == nil {
				m.LastError = &Job_NullableTime{}
			}
			if err := m.LastError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Processors == nil {
				m.Processors = make(map[string]*PluginConfig)
			}
			var mapkey string
			var mapvalue *PluginConfig
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpiderjob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PluginConfig{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpiderjob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Processors[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job_NullableTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullableTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullableTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasValue = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &protobuf.Timestamp{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PluginConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PluginConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PluginConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSpiderjob
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSpiderjob
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSpiderjob(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSpiderjob
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Output", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Output = append(m.Output[:0], dAtA[iNdEx:postIndex]...)
			if m.Output == nil {
				m.Output = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempt", wireType)
			}
			m.Attempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &protobuf.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinishedAt == nil {
				m.FinishedAt = &protobuf.Timestamp{}
			}
			if err := m.FinishedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionDoneRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionDoneRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionDoneRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Execution == nil {
				m.Execution = &Execution{}
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionDoneResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionDoneResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionDoneResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToggleJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToggleJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToggleJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ToggleJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ToggleJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ToggleJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftServer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Node = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Leader = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Voter = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftProtocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftProtocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftGetConfigurationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftGetConfigurationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftGetConfigurationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &RaftServer{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftRemovePeerByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRemovePeerByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRemovePeerByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentRunStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentRunStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentRunStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Execution == nil {
				m.Execution = &Execution{}
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentRunResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentRunResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentRunResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetActiveExecutionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetActiveExecutionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetActiveExecutionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executions = append(m.Executions, &Execution{})
			if err := m.Executions[len(m.Executions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentRunRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentRunRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentRunRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSpiderjob
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Execution == nil {
				m.Execution = &Execution{}
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSpiderjob(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSpiderjob
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSpiderjob(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSpiderjob
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSpiderjob
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSpiderjob
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSpiderjob
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSpiderjob
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSpiderjob        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSpiderjob          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSpiderjob = fmt.Errorf("proto: unexpected end of group")
)
